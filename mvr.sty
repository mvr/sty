\ProvidesPackage{mvr}

\usepackage[T1]{fontenc}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

% Remove the * from the \thanks footnote
\def\thanks#1{\protected@xdef\@thanks{\@thanks\protect\footnotetext{#1}}}

\usepackage{microtype}

% Uncomment if immortal
%\usepackage{mlmodern}

% Other font choices
%\usepackage{libertine}
%\usepackage{garamondlibre}

\usepackage{array}
\setlength{\arraycolsep}{0pt}% no padding
\newcolumntype{B}{>{{}}c<{{}}}

\usepackage{xcolor}

% replace mathfrak
\DeclareFontFamily{U}{yswab}{}
\DeclareFontShape{U}{yswab}{m}{n}{<->yswab}{}
\newcommand{\mathswab}[1]{\text{\usefont{U}{yswab}{m}{n}#1}}
\renewcommand{\mathfrak}[1]{\mathswab{#1}}

% \usepackage{tikz-cd}
% \usepackage{mathpartir}

% TODO: investigate
% \usepackage{booktabs}

\usepackage[status=draft,inline,nomargin]{fixme}
\FXRegisterAuthor{mvr}{anmvr}{\color{blue}MVR}
%\FXRegisterAuthor{drl}{andrl}{\color{red}DRL}

% Should come last
\usepackage{hyperref}
\@ifclassloaded{beamer}{}{
  %% These break theorem environments in beamer
  \usepackage[capitalise]{cleveref}
  \hypersetup{colorlinks,allcolors=[rgb]{0.1,0.1,0.4}}
%  \hypersetup{colorlinks,citecolor=black,linkcolor=black}
}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
% Via Mike:
% From http://tex.stackexchange.com/questions/159698/referencing-unnumbered-theorems
\newtheorem*{namedthm}{\protect\namedthmname}
\newcounter{namedthm}
\newenvironment{named}[1]
  {\def\namedthmname{#1}%
   \refstepcounter{namedthm}%
   \begin{namedthm}\def\@currentlabel{#1}}
  {\end{namedthm}}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{examples}[theorem]{Examples}
\newtheorem{question}{Question}

%% Fix emptyset symbol
\let\oldemptyset\emptyset%
\renewcommand{\emptyset}{\varnothing}

%% Fix wedge/smash
\let\oldwedge\wedge%
\renewcommand{\wedge}{\vee}
\newcommand{\topsmash}{\oldwedge}

%% Fix equiv and defeq
\let\oldequiv\equiv%
\renewcommand{\equiv}{\simeq}
\newcommand{\defeq}{\oldequiv}
\newcommand{\ndefeq}{\not\defeq}

%% Shape modality
\usepackage[safe]{tipa}
\newcommand{\esh}{\ensuremath{\text{\textesh}}}
\newcommand{\shape}{\ensuremath{\mathord{\raisebox{0.5pt}{\text{\rm\esh}}}}}

%% Basic maths stuff
\newcommand{\abs}[1]{\lvert #1 \rvert}
\DeclareMathOperator{\colim}{colim}
\DeclareMathOperator{\cofib}{cofib}
\DeclareMathOperator{\ob}{ob}
\newcommand{\op}{\mathsf{op}}
\newcommand*{\lolli}{\multimap}

%% Basic Judgements
\newcommand{\rulen}[1]{\textsc{#1}}
\newcommand{\yields}{\vdash}
\newcommand{\cbar}{\, | \,}
\newcommand{\judge}{\mathcal{J}}
\newcommand{\freshfor}{\mathbin{\#}}

\newcommand{\ctx}{\,\,\mathsf{ctx}}
\newcommand{\type}{\,\,\mathsf{type}}
\newcommand{\tele}{\,\,\mathsf{tele}}

\newcommand{\rawctx}{\,\,\mathsf{rawctx}}
\newcommand{\rawtele}{\,\,\mathsf{rawtele}}
\newcommand{\rawterm}{\,\,\mathsf{rawterm}}

% Ordinary HoTT notation
\newcommand{\Idsym}{\mathsf{Id}}
% \newcommand{\Id}[3]{\mathsf{Id}_{{#1}}(#2,#3)}

\newcommand{\pathcat}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
           }
           
\newcommand*{\trunc}[2]{\mathopen{}\left\Vert #2\right\Vert_{#1}\mathclose{}}
\newcommand*{\strunc}[2]{\mathopen{}\left\Vert #2\right\Vert_{#1}^s\mathclose{}}
\newcommand*{\univ}{\mathcal{U}}
\newcommand*{\NN}{\mathbb{N}}
\newcommand*{\ZZ}{\mathbb{Z}}
\newcommand*{\id}{\mathsf{id}}
\newcommand*{\proj}{\mathsf{pr}}
\newcommand*{\pushpr}{\mathbin{\wasysquare}}
\newcommand*{\join}{\ast}
\newcommand*{\ap}{\mathsf{ap}}
\newcommand*{\transp}{\mathsf{tr}}
\newcommand*{\isContr}{\mathsf{isContr}}
\newcommand*{\isEquiv}{\mathsf{isEquiv}}
\newcommand*{\isModal}{\mathsf{isModal}}
\newcommand*{\inl}{\mathsf{inl}}
\newcommand*{\inr}{\mathsf{inr}}
\newcommand*{\glue}{\mathsf{glue}}
\newcommand*{\code}{\mathsf{code}}
\newcommand*{\encode}{\mathsf{encode}}
\newcommand*{\decode}{\mathsf{decode}}
\newcommand*{\const}{\mathsf{const}}
\newcommand*{\fib}{\mathsf{fib}}
\newcommand*{\case}{\mathsf{case}}
\newcommand*{\ind}[3]{\mathsf{let} \; {#2} := {#1} \, \mathsf{in} \, {#3}}
\newcommand*{\pathind}[3]{\mathsf{let} \; \refl{#2} := {#1} \, \mathsf{in} \, {#3}}
\newcommand*{\refl}[1]{\mathsf{refl}_{#1}}
\newcommand*{\bang}{\mathord{!}}

\newcommand{\lbparen}{%
  \mathopen{%
    \sbox0{$()$}%
    \setlength{\unitlength}{\dimexpr\ht0+\dp0}%
    \raisebox{-\dp0}{%
      \begin{picture}(.32,1)
      \linethickness{\fontdimen8\textfont3}
      \roundcap
      \put(0,0){\raisebox{\depth}{$($}}
      \polyline(0.32,0)(0,0)(0,1)(0.32,1)
      \end{picture}%
    }%
  }%
}

\newcommand{\rbparen}{%
  \mathclose{%
    \sbox0{$()$}%
    \setlength{\unitlength}{\dimexpr\ht0+\dp0}%
    \raisebox{-\dp0}{%
      \begin{picture}(.32,1)
      \linethickness{\fontdimen8\textfont3}
      \roundcap
      \put(-0.08,0){\raisebox{\depth}{$)$}}
      \polyline(0,0)(0.32,0)(0.32,1)(0,1)
      \end{picture}%
    }%
  }%
}

%%%%%%%%%%%%%%
%%% Stolen ("adapted") from Mike:
%%% Big smash and Big hom formatted in the style of the HoTT book
%
%%%% Dependent products %%%
%\def\prdsym{\textstyle\prod}
%%% Call the macro like \prd{x,y:A}{p:x=y} with any number of
%%% arguments.  Make sure that whatever comes *after* the call doesn't
%%% begin with an open-brace, or it will be parsed as another argument.
%\makeatletter
%% Currently the macro is configured to produce
%%     {\textstyle\prod}(x:A) \; {\textstyle\prod}(y:B),{\ }
%% in display-math mode, and
%%     \prod_{(x:A)} \prod_{y:B}
%% in text-math mode.
%% \def\prd#1{\@ifnextchar\bgroup{\prd@parens{#1}}{%
%%     \@ifnextchar\sm{\prd@parens{#1}\@eatsm}{%
%%         \prd@noparens{#1}}}}
%\def\prd#1{\@ifnextchar\bgroup{\prd@parens{#1}}{%
%    \@ifnextchar\sm{\prd@parens{#1}\@eatsm}{%
%    \@ifnextchar\prd{\prd@parens{#1}\@eatprd}{%
%    \@ifnextchar\;{\prd@parens{#1}\@eatsemicolonspace}{%
%    \@ifnextchar\\{\prd@parens{#1}\@eatlinebreak}{%
%    \@ifnextchar\narrowbreak{\prd@parens{#1}\@eatnarrowbreak}{%
%      \prd@noparens{#1}}}}}}}}
%\def\prd@parens#1{\@ifnextchar\bgroup%
%  {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\prd@parens}%
%  {\@ifnextchar\sm%
%    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}\@eatsm}%
%    {\mathchoice{\@dprd{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}}}
%\def\@eatsm\sm{\sm@parens}
%\def\prd@noparens#1{\mathchoice{\@dprd@noparens{#1}}{\@tprd{#1}}{\@tprd{#1}}{\@tprd{#1}}}
%% Helper macros for three styles
%\def\lprd#1{\@ifnextchar\bgroup{\@lprd{#1}\lprd}{\@@lprd{#1}}}
%\def\@lprd#1{\mathchoice{{\textstyle\prod}}{\prod}{\prod}{\prod}({\textstyle #1})\;}
%\def\@@lprd#1{\mathchoice{{\textstyle\prod}}{\prod}{\prod}{\prod}({\textstyle #1}),\ }
%\def\tprd#1{\@tprd{#1}\@ifnextchar\bgroup{\tprd}{}}
%\def\@tprd#1{\mathchoice{{\textstyle\prod_{(#1)}}}{\prod_{(#1)}}{\prod_{(#1)}}{\prod_{(#1)}}}
%\def\dprd#1{\@dprd{#1}\@ifnextchar\bgroup{\dprd}{}}
%\def\@dprd#1{\prod_{(#1)}\,}
%\def\@dprd@noparens#1{\prod_{#1}\,}
%
%% Look through spaces and linebreaks
%\def\@eatnarrowbreak\narrowbreak{%
%  \@ifnextchar\prd{\narrowbreak\@eatprd}{%
%    \@ifnextchar\sm{\narrowbreak\@eatsm}{%
%      \narrowbreak}}}
%\def\@eatlinebreak\\{%
%  \@ifnextchar\prd{\\\@eatprd}{%
%    \@ifnextchar\sm{\\\@eatsm}{%
%      \\}}}
%\def\@eatsemicolonspace\;{%
%  \@ifnextchar\prd{\;\@eatprd}{%
%    \@ifnextchar\sm{\;\@eatsm}{%
%      \;}}}
%
%%%% Lambda abstractions.
%% Each variable being abstracted over is a separate argument.  If
%% there is more than one such argument, they *must* be enclosed in
%% braces.  Arguments can be untyped, as in \lam{x}{y}, or typed with a
%% colon, as in \lam{x:A}{y:B}. In the latter case, the colons are
%% automatically noticed and (with current implementation) the space
%% around the colon is reduced.  You can even give more than one variable
%% the same type, as in \lam{x,y:A}.
%\def\lam#1{{\lambda}\@lamarg#1:\@endlamarg\@ifnextchar\bgroup{.\,\lam}{.\,}}
%\def\@lamarg#1:#2\@endlamarg{\if\relax\detokenize{#2}\relax #1\else\@lamvar{\@lameatcolon#2},#1\@endlamvar\fi}
%\def\@lamvar#1,#2\@endlamvar{(#2\,{:}\,#1)}
%% \def\@lamvar#1,#2{{#2}^{#1}\@ifnextchar,{.\,{\lambda}\@lamvar{#1}}{\let\@endlamvar\relax}}
%\def\@lameatcolon#1:{#1}
%\let\lamt\lam
%% This version silently eats any typing annotation.
%\def\lamu#1{{\lambda}\@lamuarg#1:\@endlamuarg\@ifnextchar\bgroup{.\,\lamu}{.\,}}
%\def\@lamuarg#1:#2\@endlamuarg{#1}
%
%%%%% Dependent products written with \forall, in the same style
%%\def\fall#1{\forall (#1)\@ifnextchar\bgroup{.\,\fall}{.\,}}
%%
%%%%% Existential quantifier %%%
%%\def\exis#1{\exists (#1)\@ifnextchar\bgroup{.\,\exis}{.\,}}
%
%%%% Dependent sums %%%
%\def\smsym{\textstyle\sum}
%% Use in the same way as \prd
%\def\sm#1{\@ifnextchar\bgroup{\sm@parens{#1}}{%
%    \@ifnextchar\prd{\sm@parens{#1}\@eatprd}{%
%    \@ifnextchar\sm{\sm@parens{#1}\@eatsm}{%
%    \@ifnextchar\;{\sm@parens{#1}\@eatsemicolonspace}{%
%    \@ifnextchar\\{\sm@parens{#1}\@eatlinebreak}{%
%    \@ifnextchar\narrowbreak{\sm@parens{#1}\@eatnarrowbreak}{%
%        \sm@noparens{#1}}}}}}}}
%\def\sm@parens#1{\@ifnextchar\bgroup%
%  {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\sm@parens}%
%  {\@ifnextchar\prd%
%    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}\@eatprd}%
%    {\mathchoice{\@dsm{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}}}
%\def\@eatprd\prd{\prd@parens}
%\def\sm@noparens#1{\mathchoice{\@dsm@noparens{#1}}{\@tsm{#1}}{\@tsm{#1}}{\@tsm{#1}}}
%\def\lsm#1{\@ifnextchar\bgroup{\@lsm{#1}\lsm}{\@@lsm{#1}}}
%\def\@lsm#1{\mathchoice{{\textstyle\sum}}{\sum}{\sum}{\sum}({\textstyle #1})\;}
%\def\@@lsm#1{\mathchoice{{\textstyle\sum}}{\sum}{\sum}{\sum}({\textstyle #1}),\ }
%\def\tsm#1{\@tsm{#1}\@ifnextchar\bgroup{\tsm}{}}
%\def\@tsm#1{\mathchoice{{\textstyle\sum_{(#1)}}}{\sum_{(#1)}}{\sum_{(#1)}}{\sum_{(#1)}}}
%\def\dsm#1{\@dsm{#1}\@ifnextchar\bgroup{\dsm}{}}
%\def\@dsm#1{\sum_{(#1)}\,}
%\def\@dsm@noparens#1{\sum_{#1}\,}
%\makeatother

%%%%%%%%%%%%%%
%%% Stolen ("adapted") from Egbert:
%%% More compact sm, prd, with the first argument
%%% to the lower right rather than vertically below.

\def\smsym{\sum}
\newcommand{\@thesum}[1]{\smsym_{(#1)}}
\newcommand{\sm}[1]{\@ifnextchar\bgroup{\@sm{#1}\sm}{\@sm{#1}}}
\newcommand{\@sm}[1]{\mathchoice{{\textstyle\@thesum{#1}}}{\@thesum{#1}}{\@thesum{#1}}{\@thesum{#1}}}
\def\prdsym{\prod}
\newcommand{\@theprd}[1]{\prdsym_{(#1)}}
\newcommand{\prd}[1]{\@ifnextchar\bgroup{\@prd{#1}\prd}{\@prd{#1}}}
\newcommand{\@prd}[1]{\mathchoice{{\textstyle\@theprd{#1}}}{\@theprd{#1}}{\@theprd{#1}}{\@theprd{#1}}}

%%%%%%%%%%%%%%
%%% Even more compact Agda style sm, prd

%\makeatletter
%\newcommand{\@thesum}[1]{(#1) \times}
%\newcommand{\sm}[1]{\@ifnextchar\bgroup{\@thesum{#1}\sm}{\@thesum{#1}}}
%\newcommand{\@theprd}[1]{(#1) \to}
%\newcommand{\prd}[1]{\@ifnextchar\bgroup{\@theprd{#1}\prd}{\@theprd{#1}}}
%\makeatother

